var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [RBMsAnnealedImportanceSampling]","category":"page"},{"location":"reference/#RBMsAnnealedImportanceSampling.ais-Tuple{RestrictedBoltzmannMachines.RBM, RestrictedBoltzmannMachines.RBM, AbstractArray, AbstractVector}","page":"Reference","title":"RBMsAnnealedImportanceSampling.ais","text":"ais(rbm0, rbm1, v0, βs)\n\nProvided v0 is an equilibrated sample from rbm0, returns F such that mean(exp.(F)) is an unbiased estimator of Z1/Z0, the ratio of partition functions of rbm1 and rbm0.\n\n!!! tip Use logmeanexp     logmeanexp(F), using the function logmeanexp[@ref] provided in this package,     tends to give a better approximation of log(Z1) - log(Z0) than mean(F).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RBMsAnnealedImportanceSampling.aise-Tuple{RestrictedBoltzmannMachines.RBM, AbstractVector{<:Real}}","page":"Reference","title":"RBMsAnnealedImportanceSampling.aise","text":"aise(rbm, [βs]; [nbetas], init=rbm.visible, nsamples=1)\n\nAIS estimator of the log-partition function of rbm. It is recommended to fit init to the single-site statistics of rbm (or the data).\n\n!!! tip Use large nbetas     For more accurate estimates, use larger nbetas. It is usually better to have     large nbetas and small nsamples, rather than large nsamples and small nbetas.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RBMsAnnealedImportanceSampling.anneal-Tuple{RestrictedBoltzmannMachines.RBM, RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RBMsAnnealedImportanceSampling.anneal","text":"anneal(rbm0, rbm1; β)\n\nReturns an RBM that interpolates between rbm0 and rbm1. Denoting by E0(v, h) and E1(v, h) the energies assigned by rbm0 and rbm1, respectively, the returned RBM assigns energies given by:\n\nE(v,h) = (1 - β) * E0(v) + β * E1(v, h)\n\n\n\n\n\n","category":"method"},{"location":"reference/#RBMsAnnealedImportanceSampling.log_partition_zero_weight-Tuple{Any}","page":"Reference","title":"RBMsAnnealedImportanceSampling.log_partition_zero_weight","text":"log_partition_zero_weight(rbm)\n\nLog-partition function of a zero-weight version of rbm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RBMsAnnealedImportanceSampling.logmeanexp-Tuple{AbstractArray}","page":"Reference","title":"RBMsAnnealedImportanceSampling.logmeanexp","text":"logmeanexp(A; dims=:)\n\nComputes log.(mean(exp.(A); dims)), in a numerically stable way.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RBMsAnnealedImportanceSampling.logstdexp-Tuple{AbstractArray}","page":"Reference","title":"RBMsAnnealedImportanceSampling.logstdexp","text":"logstdexp(A; dims=:)\n\nComputes log.(std(exp.(A); dims)), in a numerically stable way.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RBMsAnnealedImportanceSampling.logvarexp-Tuple{AbstractArray}","page":"Reference","title":"RBMsAnnealedImportanceSampling.logvarexp","text":"logvarexp(A; dims=:)\n\nComputes log.(var(exp.(A); dims)), in a numerically stable way.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RBMsAnnealedImportanceSampling.raise-Tuple{RestrictedBoltzmannMachines.RBM, AbstractVector}","page":"Reference","title":"RBMsAnnealedImportanceSampling.raise","text":"raise(rbm::RBM, βs; v, init)\n\nReverse AIS estimator of the log-partition function of rbm. While aise tends to understimate the log of the partition function, raise tends to overstimate it. v must be an equilibrated sample from rbm.\n\n!!! tip Use logmeanexp     If F = raise(...), then -logmeanexp(-F), using the function logmeanexp[@ref]     provided in this package, tends to give a better approximation of log(Z) than mean(F).\n\n!!! tip Sandwiching the log-partition function     If Rf = aise(...), Rr = raise(...) are the AIS and reverse AIS estimators, we have the     stochastic bounds logmeanexp(Rf) ≤ log(Z) ≤ -logmeanexp(-Rr).\n\n\n\n\n\n","category":"method"},{"location":"#RBMsAnnealedImportanceSampling.jl-Documentation","page":"Home","title":"RBMsAnnealedImportanceSampling.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Annealed importance sampling algorithm to estimate the partition function of Restricted Boltzmann machines. The package is registered. Install it with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"RBMsAnnealedImportanceSampling\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The source code is hosted on Github.","category":"page"},{"location":"","page":"Home","title":"Home","text":"https://github.com/cossio/RBMsAnnealedImportanceSampling.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package doesn't export any symbols. It can be imported like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import RBMsAnnealedImportanceSampling as AIS","category":"page"},{"location":"","page":"Home","title":"Home","text":"to avoid typing a long name everytime.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the functions have a helpful docstring. See Reference section. See also the Examples listed on the menu on the left side bar to understand how the package works as a whole.","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"EditURL = \"https://github.com/cossio/RBMsAnnealedImportanceSampling.jl/blob/master/docs/src/literate/ais.jl\"","category":"page"},{"location":"literate/ais/#Annealed-importance-sampling","page":"AIS","title":"Annealed importance sampling","text":"","category":"section"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"We can compute the partition function of the RBM (and hence the log-likelihood) with annealed importance sampling (AIS).","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"import MLDatasets\nimport Makie\nimport CairoMakie\nusing Statistics: mean, std, middle\nusing RBMsAnnealedImportanceSampling: aise, raise, logmeanexp, logstdexp\nusing RestrictedBoltzmannMachines: Binary, BinaryRBM, initialize!, pcd!, sample_v_from_v","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Load MNIST (0 digit only).","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"train_x = MLDatasets.MNIST(split=:train)[:].features .> 0.5\ntrain_y = MLDatasets.MNIST(split=:train)[:].targets\ntrain_x = train_x[:, :, train_y .== 0]\nnothing #hide","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Train an RBM","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"rbm = BinaryRBM((28,28), 128)\ninitialize!(rbm, train_x)\n@time pcd!(rbm, train_x; iters=10000, batchsize=128)\nnothing #hide","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Get some equilibrated samples from model","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"v = train_x[:, :, rand(1:size(train_x, 3), 1000)]\nv = sample_v_from_v(rbm, v; steps=1000)\nnothing #hide","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Estimate Z with AIS and reverse AIS.","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"nsamples=100\nndists = [10, 100, 1000, 10_000, 100_000]\nR_ais = Vector{Float64}[]\nR_rev = Vector{Float64}[]\ninit = initialize!(Binary(; θ = zero(rbm.visible.θ)), v)\nnothing #hide\n\nfor nbetas in ndists\n    push!(R_ais,\n        @time aise(rbm; nbetas, nsamples, init)\n    )\n    push!(R_rev,\n        @time raise(rbm; nbetas, init, v=v[:,:,rand(1:size(v, 3), nsamples)])\n    )\nend","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Plots","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"fig = Makie.Figure()\nax = Makie.Axis(\n    fig[1,1], width=700, height=400, xscale=log10, xlabel=\"interpolating distributions\", ylabel=\"log(Z)\"\n)\nMakie.band!(\n    ax, ndists,\n    mean.(R_ais) - std.(R_ais),\n    mean.(R_ais) + std.(R_ais);\n    color=(:blue, 0.25)\n)\nMakie.band!(\n    ax, ndists,\n    mean.(R_rev) - std.(R_rev),\n    mean.(R_rev) + std.(R_rev);\n    color=(:black, 0.25)\n)\nMakie.lines!(ax, ndists, mean.(R_ais); color=:blue, label=\"AIS\")\nMakie.lines!(ax, ndists, mean.(R_rev); color=:black, label=\"reverse AIS\")\nMakie.lines!(ax, ndists, logmeanexp.(R_ais); color=:blue, linestyle=:dash)\nMakie.lines!(ax, ndists, logmeanexp.(R_rev); color=:black, linestyle=:dash)\nMakie.lines!(ax, ndists, -logmeanexp.(-R_rev); color=:orange, linestyle=:dash)\nMakie.hlines!(ax, middle(mean(R_ais[end]), mean(R_rev[end])), linestyle=:dash, color=:red, label=\"limiting estimate\")\nMakie.xlims!(extrema(ndists)...)\nMakie.axislegend(ax, position=:rb)\nMakie.resize_to_layout!(fig)\nfig","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"This page was generated using Literate.jl.","category":"page"}]
}
